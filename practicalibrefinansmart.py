# -*- coding: utf-8 -*-
"""PracticalibreFinanSmart.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mSRTiQ7Inx1xKWIVKfdyErt4mY43g0IG
"""

# Importamos Yfinance
import yfinance as yf

# Definimos los Tickers
tickers = ["AAPL", "MSFT", "AMZN", "GOOGL", "META"]

# Descargamos los precions ajustados de cierrre (Adjusted Close)
# Estos precios corrigen splits y dividendos, lo que los hace adecuados para análisis financiero
data = yf.download(tickers, start='2020-01-01', end='2023-12-31')['Close']

# Visualizamos las primeras filas para verificar las estructura de los datos
data.head()

import matplotlib.pyplot as plt

data.plot(figsize=(10,6), title='Evolución de precios ajustados')
plt.show()

# Calculamos el retorno porcentual diario
returns = data.pct_change().dropna()

# Mostramos estadísticas descriptivas (media, desviación, etc.)
returns.describe()

returns.plot(figsize=(10,6), alpha=0.7, title='Retornos diarios')
plt.show()

import seaborn as sns
sns.heatmap(returns.corr(), annot=True, cmap='coolwarm')
plt.title('Matriz de correlación del portafolio')
plt.show()

import numpy as np
import pandas as pd

# Rendimiento medio diario multiplicado por 252 días hábiles del año
mean_returns = returns.mean() * 252

# Desviación estándar diaria multiplicada por la raíz de 252 para anualizar el riesgo
risk = returns.std() * np.sqrt(252)

# Mostramos ambos valores en una tabla
pd.DataFrame({'Rendimiento Anual': mean_returns, 'Riesgo (Volatilidad)': risk})

# Asignamos pesos iguales a cada activo
weights = np.array([1/len(tickers)] * len(tickers))

# Rendimiento esperado del portafolio = suma ponderada de los rendimientos individuales
portfolio_return = np.dot(weights, mean_returns)

# Riesgo del portafolio considerando la covarianza entre activos
portfolio_risk = np.sqrt(np.dot(weights.T, np.dot(returns.cov() * 252, weights)))

print(f'Rendimiento esperado del portafolio: {portfolio_return:.2%}')
print(f'Riesgo del portafolio: {portfolio_risk:.2%}')

num_portfolios = 10000  # Número de portafolios a simular
results = np.zeros((3, num_portfolios))  # Matriz para almacenar riesgo, retorno y Sharpe

for i in range(num_portfolios):
    weights = np.random.random(len(tickers))  # Generamos pesos aleatorios
    weights /= np.sum(weights)  # Normalizamos para que sumen 1
    ret = np.dot(weights, mean_returns)  # Rendimiento esperado
    risk = np.sqrt(np.dot(weights.T, np.dot(returns.cov() * 252, weights)))  # Riesgo total
    sharpe = ret / risk  # Índice de Sharpe
    results[0,i] = risk
    results[1,i] = ret
    results[2,i] = sharpe

# Visualizamos la frontera eficiente
plt.scatter(results[0,:], results[1,:], c=results[2,:], cmap='viridis', alpha=0.5)
plt.xlabel('Riesgo (Volatilidad)')
plt.ylabel('Retorno Esperado')
plt.title('Frontera Eficiente Simulada')
plt.colorbar(label='Índice de Sharpe')
plt.show()

max_sharpe_idx = np.argmax(results[2])
mejor_riesgo, mejor_retorno, mejor_sharpe = results[:, max_sharpe_idx]

print(f'Mejor Índice de Sharpe: {mejor_sharpe:.2f}')
print(f'Retorno esperado: {mejor_retorno:.2%}')
print(f'Riesgo asociado: {mejor_riesgo:.2%}')

df_resultados = pd.DataFrame(results.T, columns=['Riesgo', 'Retorno', 'Sharpe'])
df_resultados.to_csv('resultados_portafolio.csv', index=False)
df_resultados.head()